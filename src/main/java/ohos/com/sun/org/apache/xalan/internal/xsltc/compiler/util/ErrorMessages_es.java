package ohos.com.sun.org.apache.xalan.internal.xsltc.compiler.util;

import java.util.ListResourceBundle;

public class ErrorMessages_es extends ListResourceBundle {
    public Object[][] getContents() {
        return new Object[][]{new Object[]{ErrorMsg.MULTIPLE_STYLESHEET_ERR, "Se ha definido más de una hoja de estilo en el mismo archivo."}, new Object[]{ErrorMsg.TEMPLATE_REDEF_ERR, "La plantilla ''{0}'' ya se ha definido en esta hoja de estilo."}, new Object[]{ErrorMsg.TEMPLATE_UNDEF_ERR, "La plantilla ''{0}'' no se ha definido en esta hoja de estilo."}, new Object[]{ErrorMsg.VARIABLE_REDEF_ERR, "Se ha definido varias veces la variable ''{0}'' en el mismo ámbito."}, new Object[]{ErrorMsg.VARIABLE_UNDEF_ERR, "No se ha definido la variable o el parámetro ''{0}''."}, new Object[]{ErrorMsg.CLASS_NOT_FOUND_ERR, "No se ha encontrado la clase ''{0}''."}, new Object[]{ErrorMsg.METHOD_NOT_FOUND_ERR, "No se ha encontrado el método externo ''{0}'' (debe ser público)."}, new Object[]{ErrorMsg.ARGUMENT_CONVERSION_ERR, "No se puede convertir el tipo de argumento/retorno en la llamada al método ''{0}''"}, new Object[]{ErrorMsg.FILE_NOT_FOUND_ERR, "No se ha encontrado el archivo o URI ''{0}''."}, new Object[]{ErrorMsg.INVALID_URI_ERR, "URI ''{0}'' no válido."}, new Object[]{ErrorMsg.FILE_ACCESS_ERR, "No se puede abrir el archivo o URI ''{0}''."}, new Object[]{ErrorMsg.MISSING_ROOT_ERR, "Se esperaba el elemento <xsl:stylesheet> o <xsl:transform>."}, new Object[]{ErrorMsg.NAMESPACE_UNDEF_ERR, "No se ha declarado el prefijo de espacio de nombres ''{0}''."}, new Object[]{ErrorMsg.FUNCTION_RESOLVE_ERR, "No se ha podido resolver la llamada a la función ''{0}''."}, new Object[]{ErrorMsg.NEED_LITERAL_ERR, "El argumento en ''{0}'' debe ser una cadena literal."}, new Object[]{ErrorMsg.XPATH_PARSER_ERR, "Error al analizar la expresión XPath ''{0}''."}, new Object[]{ErrorMsg.REQUIRED_ATTR_ERR, "Falta el atributo ''{0}'' necesario."}, new Object[]{ErrorMsg.ILLEGAL_CHAR_ERR, "Carácter ''{0}'' no permitido en la expresión XPath."}, new Object[]{ErrorMsg.ILLEGAL_PI_ERR, "Nombre ''{0}'' no permitido para la instrucción de procesamiento."}, new Object[]{"STRAY_ATTRIBUTE_ERR", "El atributo ''{0}'' está fuera del elemento."}, new Object[]{ErrorMsg.ILLEGAL_ATTRIBUTE_ERR, "Atributo ''{0}'' no permitido."}, new Object[]{ErrorMsg.CIRCULAR_INCLUDE_ERR, "Import/include circular. La hoja de estilo ''{0}'' ya se ha cargado."}, new Object[]{ErrorMsg.RESULT_TREE_SORT_ERR, "Los fragmentos del árbol de resultados no se pueden ordenar (los elementos <xsl:sort> se ignoran). Debe ordenar los nodos al crear el árbol de resultados."}, new Object[]{ErrorMsg.SYMBOLS_REDEF_ERR, "Ya se ha definido el formato decimal ''{0}''."}, new Object[]{ErrorMsg.XSL_VERSION_ERR, "La versión XSL ''{0}'' no está soportada por XSLTC."}, new Object[]{ErrorMsg.CIRCULAR_VARIABLE_ERR, "La referencia de variable/parámetro circular en ''{0}''."}, new Object[]{ErrorMsg.ILLEGAL_BINARY_OP_ERR, "Operador desconocido para la expresión binaria."}, new Object[]{ErrorMsg.ILLEGAL_ARG_ERR, "Argumentos no permitidos para la llamada de función."}, new Object[]{ErrorMsg.DOCUMENT_ARG_ERR, "El segundo argumento en la función document() debe ser un juego de nodos."}, new Object[]{ErrorMsg.MISSING_WHEN_ERR, "Se necesita al menos un elemento <xsl:when> en <xsl:choose>."}, new Object[]{ErrorMsg.MULTIPLE_OTHERWISE_ERR, "Sólo se permite un elemento <xsl:otherwise> en <xsl:choose>."}, new Object[]{ErrorMsg.STRAY_OTHERWISE_ERR, "<xsl:otherwise> sólo se puede utilizar en <xsl:choose>."}, new Object[]{ErrorMsg.STRAY_WHEN_ERR, "<xsl:when> sólo se puede utilizar en <xsl:choose>."}, new Object[]{ErrorMsg.WHEN_ELEMENT_ERR, "Sólo se permiten los elementos <xsl:when> y <xsl:otherwise> en <xsl:choose>."}, new Object[]{ErrorMsg.UNNAMED_ATTRIBSET_ERR, "Falta el atributo 'name' en <xsl:attribute-set>"}, new Object[]{ErrorMsg.ILLEGAL_CHILD_ERR, "Elemento secundario no permitido."}, new Object[]{ErrorMsg.ILLEGAL_ELEM_NAME_ERR, "No se puede llamar ''{0}'' a un elemento"}, new Object[]{ErrorMsg.ILLEGAL_ATTR_NAME_ERR, "No se puede llamar ''{0}'' a un atributo"}, new Object[]{ErrorMsg.ILLEGAL_TEXT_NODE_ERR, "Datos de texto fuera del elemento <xsl:stylesheet> de nivel superior."}, new Object[]{ErrorMsg.SAX_PARSER_CONFIG_ERR, "El analizador JAXP no se ha configurado correctamente"}, new Object[]{ErrorMsg.INTERNAL_ERR, "Error interno de XSLTC irrecuperable: ''{0}''"}, new Object[]{"UNSUPPORTED_XSL_ERR", "Elemento ''{0}'' de XSL no soportado."}, new Object[]{"UNSUPPORTED_EXT_ERR", "Extensión ''{0}'' de XSLTC no reconocida."}, new Object[]{ErrorMsg.MISSING_XSLT_URI_ERR, "El documento de entrada no es una hoja de estilo (el espacio de nombres XSL no se ha declarado en el elemento raíz)."}, new Object[]{ErrorMsg.MISSING_XSLT_TARGET_ERR, "No se ha encontrado el destino de hoja de estilo ''{0}''."}, new Object[]{ErrorMsg.ACCESSING_XSLT_TARGET_ERR, "No se ha podido leer el destino de hoja de estilos ''{0}'', porque no se permite el acceso ''{1}'' debido a una restricción definida por la propiedad accessExternalStylesheet."}, new Object[]{ErrorMsg.NOT_IMPLEMENTED_ERR, "No implantado: ''{0}''."}, new Object[]{ErrorMsg.NOT_STYLESHEET_ERR, "El documento de entrada no contiene una hoja de estilo XSL."}, new Object[]{ErrorMsg.ELEMENT_PARSE_ERR, "No se ha podido analizar el elemento ''{0}''"}, new Object[]{ErrorMsg.KEY_USE_ATTR_ERR, "El atributo use de <key> debe ser node, node-set, string o number."}, new Object[]{ErrorMsg.OUTPUT_VERSION_ERR, "La versión del documento XML de salida debe ser 1.0"}, new Object[]{ErrorMsg.ILLEGAL_RELAT_OP_ERR, "Operador desconocido para la expresión relacional"}, new Object[]{ErrorMsg.ATTRIBSET_UNDEF_ERR, "Se está intentando utilizar el juego de atributos ''{0}'' no existente."}, new Object[]{ErrorMsg.ATTR_VAL_TEMPLATE_ERR, "No se puede analizar la plantilla del valor de atributo ''{0}''."}, new Object[]{ErrorMsg.UNKNOWN_SIG_TYPE_ERR, "Tipo de datos desconocido en la firma para la clase ''{0}''."}, new Object[]{"DATA_CONVERSION_ERR", "No se puede convertir el tipo de datos ''{0}'' en ''{1}''."}, new Object[]{ErrorMsg.NO_TRANSLET_CLASS_ERR, "Templates no contiene una definición de clase translet."}, new Object[]{ErrorMsg.NO_MAIN_TRANSLET_ERR, "Templates no contiene una clase con el nombre ''{0}''."}, new Object[]{ErrorMsg.TRANSLET_CLASS_ERR, "No se ha podido cargar la clase de translet ''{0}''."}, new Object[]{ErrorMsg.TRANSLET_OBJECT_ERR, "La clase de translet se ha cargado, pero no se puede crear una instancia de translet."}, new Object[]{ErrorMsg.ERROR_LISTENER_NULL_ERR, "Intentando definir ErrorListener para ''{0}'' como nulo"}, new Object[]{ErrorMsg.JAXP_UNKNOWN_SOURCE_ERR, "Sólo StreamSource, SAXSource y DOMSource están soportados por XSLTC"}, new Object[]{ErrorMsg.JAXP_NO_SOURCE_ERR, "El objeto Source que se ha transferido a ''{0}'' no tiene contenido."}, new Object[]{ErrorMsg.JAXP_COMPILE_ERR, "No se ha podido compilar la hoja de estilo"}, new Object[]{ErrorMsg.JAXP_INVALID_ATTR_ERR, "TransformerFactory no reconoce el atributo ''{0}''."}, new Object[]{ErrorMsg.JAXP_INVALID_ATTR_VALUE_ERR, "Valor no válido especificado para el atributo ''{0}''."}, new Object[]{ErrorMsg.JAXP_SET_RESULT_ERR, "setResult() debe llamarse antes de startDocument()."}, new Object[]{ErrorMsg.JAXP_NO_TRANSLET_ERR, "Transformer no tiene un objeto translet encapsulado."}, new Object[]{ErrorMsg.JAXP_NO_HANDLER_ERR, "No se ha definido el manejador de salida para el resultado de la transformación."}, new Object[]{ErrorMsg.JAXP_NO_RESULT_ERR, "El objeto Result que se ha pasado a ''{0}'' no es válido."}, new Object[]{ErrorMsg.JAXP_UNKNOWN_PROP_ERR, "Se está intentando acceder a la propiedad ''{0}'' de Transformer no válida."}, new Object[]{ErrorMsg.SAX2DOM_ADAPTER_ERR, "No se ha podido crear el adaptador SAX2DOM: ''{0}''."}, new Object[]{ErrorMsg.XSLTC_SOURCE_ERR, "Se ha llamado a XSLTCSource.build() sin haber definido la identificación del sistema."}, new Object[]{"ER_RESULT_NULL", "El resultado no debe ser nulo"}, new Object[]{ErrorMsg.JAXP_INVALID_SET_PARAM_VALUE, "El valor del parámetro {0} debe ser un objeto Java válido"}, new Object[]{ErrorMsg.COMPILE_STDIN_ERR, "La opción -i debe utilizarse con la opción -o."}, new Object[]{ErrorMsg.COMPILE_USAGE_STR, "SINOPSIS\n   java ohos.com.sun.org.apache.xalan.internal.xsltc.cmdline.Compile [-o <salida>]\n      [-d <directorio>] [-j <archivo jar>] [-p <paquete>]\n      [-n] [-x] [-u] [-v] [-h] { <hoja de estilo> | -i }\n\nOPCIONES\n   -o <salida>    asigna el nombre de <salida> al translet\n                  generado. Por defecto, el nombre del translet se\n                  deriva del nombre de <hoja de estilo>. Esta opción\n                  se ignora si se compilan varias hojas de estilo.\n   -d <directorio> especifica un directorio de destino para el translet\n   -j <archivo jar>   empaqueta las clases de translet en un archivo jar del\n                  nombre especificado como <archivo jar>\n   -p <paquete>   especifica un prefijo de nombre de paquete para todas las clases de translet n\n                  generadas.\n   -n             permite poner en línea la plantilla (comportamiento por defecto mejor\n                  sobre la media).\n   -x             activa la salida del mensaje de depuración\n   -u             interpreta los argumentos <hoja de estilo> como URL\n   -i             obliga al compilador a leer la hoja de estilo de stdin\n   -v             imprime la versión del compilador\n   -h             imprime esta sentencia de uso\n"}, new Object[]{ErrorMsg.TRANSFORM_USAGE_STR, "SYNOPSIS \n   java ohos.com.sun.org.apache.xalan.internal.xsltc.cmdline.Transform [-j <archivo jar>]\n      [-x] [-n <iteraciones>] {-u <url_documento> | <documento>}\n      <clase> [<parámetro1>=<valor1> ...]\n\n   utiliza el translet <clase> para transformar un documento XML \n   especificado como <documento>. El translet <clase> se encuentra en\n   la CLASSPATH del usuario o en el <archivo jar> especificado opcionalmente.\nOPCIONES\n   -j <archivo jar>    especifica un archivo jar desde el que cargar el translet\n   -x              activa la salida del mensaje de depuración adicional\n   -n <iteraciones> ejecuta el número de <iteraciones> de una transformación y\n                   muestra la información de la creación de perfil\n   -u <url_documento> especifica el documento de entrada XML como una URL\n"}, new Object[]{ErrorMsg.STRAY_SORT_ERR, "<xsl:sort> sólo se puede utilizar en <xsl:for-each> o <xsl:apply-templates>."}, new Object[]{ErrorMsg.UNSUPPORTED_ENCODING, "La codificación de salida ''{0}'' no está soportada en esta JVM."}, new Object[]{ErrorMsg.SYNTAX_ERR, "Error de sintaxis en ''{0}''."}, new Object[]{ErrorMsg.CONSTRUCTOR_NOT_FOUND, "No se ha encontrado el constructor externo ''{0}''."}, new Object[]{ErrorMsg.NO_JAVA_FUNCT_THIS_REF, "El primer argumento de la función Java no estática ''{0}'' no es una referencia de objeto válida."}, new Object[]{ErrorMsg.TYPE_CHECK_ERR, "Error al comprobar el tipo de la expresión ''{0}''."}, new Object[]{ErrorMsg.TYPE_CHECK_UNK_LOC_ERR, "Error al comprobar el tipo de una expresión en una ubicación desconocida."}, new Object[]{ErrorMsg.ILLEGAL_CMDLINE_OPTION_ERR, "La opción de línea de comandos ''{0}'' no es válida."}, new Object[]{ErrorMsg.CMDLINE_OPT_MISSING_ARG_ERR, "Falta un argumento necesario en la opción de línea de comandos ''{0}''."}, new Object[]{ErrorMsg.WARNING_PLUS_WRAPPED_MSG, "WARNING:  ''{0}''\n       :{1}"}, new Object[]{ErrorMsg.WARNING_MSG, "WARNING:  ''{0}''"}, new Object[]{ErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSG, "FATAL ERROR:  ''{0}''\n           :{1}"}, new Object[]{ErrorMsg.FATAL_ERR_MSG, "FATAL ERROR:  ''{0}''"}, new Object[]{ErrorMsg.ERROR_PLUS_WRAPPED_MSG, "ERROR:  ''{0}''\n     :{1}"}, new Object[]{ErrorMsg.ERROR_MSG, "ERROR:  ''{0}''"}, new Object[]{ErrorMsg.TRANSFORM_WITH_TRANSLET_STR, "Transformación que utiliza el translet ''{0}'' "}, new Object[]{ErrorMsg.TRANSFORM_WITH_JAR_STR, "Transformación que utiliza el translet ''{0}'' del archivo jar ''{1}''"}, new Object[]{ErrorMsg.COULD_NOT_CREATE_TRANS_FACT, "No se ha podido crear una instancia de la clase TransformerFactory ''{0}''."}, new Object[]{ErrorMsg.TRANSLET_NAME_JAVA_CONFLICT, "El nombre ''{0}'' no se ha podido utilizar como el nombre de la clase de translet porque contiene caracteres que no están permitidos en el nombre de la clase Java. Se ha utilizado el nombre ''{1}'' en su lugar."}, new Object[]{ErrorMsg.COMPILER_ERROR_KEY, "Errores del compilador:"}, new Object[]{ErrorMsg.COMPILER_WARNING_KEY, "Advertencias del compilador:"}, new Object[]{ErrorMsg.RUNTIME_ERROR_KEY, "Errores del translet:"}, new Object[]{"INVALID_QNAME_ERR", "Un atributo cuyo valor debe ser un QName o lista de QNames separados por espacios en blanco tenía el valor ''{0}''"}, new Object[]{"INVALID_NCNAME_ERR", "Un atributo cuyo valor debe ser un NCName tenía el valor ''{0}''"}, new Object[]{ErrorMsg.INVALID_METHOD_IN_OUTPUT, "El atributo method de un elemento <xsl:output> tenía el valor ''{0}''. El valor debe ser ''xml'', ''html'', ''text'' o qname-but-not-ncname"}, new Object[]{ErrorMsg.JAXP_GET_FEATURE_NULL_NAME, "El nombre de función no puede ser nulo en TransformerFactory.getFeature (nombre de cadena)."}, new Object[]{ErrorMsg.JAXP_SET_FEATURE_NULL_NAME, "El nombre de función no puede ser nulo en TransformerFactory.setFeature (nombre de cadena, valor booleano)."}, new Object[]{ErrorMsg.JAXP_UNSUPPORTED_FEATURE, "No se puede definir la función ''{0}''en esta fábrica del transformador."}, new Object[]{ErrorMsg.JAXP_SECUREPROCESSING_FEATURE, "FEATURE_SECURE_PROCESSING: no se puede definir la función en false cuando está presente el gestor de seguridad."}, new Object[]{ErrorMsg.OUTLINE_ERR_TRY_CATCH, "Error interno de XSLTC: el código de bytes generado contiene un bloque try-catch-finally y no se puede delimitar."}, new Object[]{ErrorMsg.OUTLINE_ERR_UNBALANCED_MARKERS, "Error interno de XSLTC: los marcadores OutlineableChunkStart y OutlineableChunkEnd deben estar equilibrados y correctamente anidados."}, new Object[]{ErrorMsg.OUTLINE_ERR_DELETED_TARGET, "Error interno de XSLTC: todavía se hace referencia a una instrucción que formaba parte de un bloque de código de bytes delimitado en el método original."}, new Object[]{ErrorMsg.OUTLINE_ERR_METHOD_TOO_BIG, "Error interno de XSLTC: un método en el translet excede la limitación de Java Virtual Machine de longitud de un método de 64 kilobytes. Normalmente, esto lo causan plantillas en una hoja de estilos demasiado grandes. Pruebe a reestructurar la hoja de estilos para utilizar plantillas más pequeñas."}, new Object[]{ErrorMsg.DESERIALIZE_TRANSLET_ERR, "Cuando la seguridad de Java está activada, el soporte para anular la serialización de TemplatesImpl está desactivado. Esto se puede sustituir definiendo la propiedad del sistema jdk.xml.enableTemplatesImplDeserialization en true."}};
    }
}
